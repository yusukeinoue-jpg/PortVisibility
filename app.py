import streamlit as st
import osmnx as ox
import pandas as pd
import re
import requests
import time
import concurrent.futures
from urllib.parse import urlparse, parse_qs
from geopy.geocoders import Nominatim

# -------------------------------------------
# 0. é§…ãƒ©ãƒ³ã‚¯å®šç¾© (P0ã€œP7)
# -------------------------------------------
# CSVãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æŠ½å‡ºã—ãŸé§…ãƒ©ãƒ³ã‚¯å®šç¾©
STATION_RANKS = {
    'P0': ['éŠ€åº§', 'æ–°å®¿', 'æ¸‹è°·', 'æ±äº¬', 'æœ‰æ¥½ç”º', 'å¤§æ‰‹ç”º', 'æ—¥æ¯”è°·', 'è¡¨å‚é“', 'æ˜æ²»ç¥å®®å‰', 'åŸå®¿', 'æ—¥æœ¬æ©‹', 'ä¸‰è¶Šå‰', 'æ±éŠ€åº§', 'æ± è¢‹', 'é’å±±ä¸€ä¸ç›®', 'å“å·', 'æ–°æ©‹', 'å…­æœ¬æœ¨', 'æµæ¯”å¯¿', 'ç§‹è‘‰åŸ', 'ä¸Šé‡', 'è¥¿æ­¦æ–°å®¿', 'ç›®é»’', 'äº”åç”°', 'å¤§å´', 'ä¸­ç›®é»’', 'ä¸‰è»’èŒ¶å±‹', 'ä»£ã€…æœ¨ä¸ŠåŸ', 'æŠ¼ä¸Š', 'æ¨ªæµœ'],
    'P1': ['äºŒé‡æ©‹å‰', 'æ–°æ—¥æœ¬æ©‹', 'è™ãƒé–€', 'å®ç”º', 'äº¬æ©‹', 'æ±ç•™', 'æ–°å®¿è¥¿å£', 'éŠ€åº§ä¸€ä¸ç›®', 'å†…å¹¸ç”º', 'éƒ½åºå‰', 'å¤–è‹‘å‰', 'è™ãƒé–€ãƒ’ãƒ«ã‚º', 'æºœæ± å±±ç‹', 'éœãƒ¶é–¢', 'å‰ç¥¥å¯º', 'ä»£ã€…æœ¨', 'ç¥è°·ç”º', 'ç¥ç”°', 'èµ¤å‚è¦‹é™„', 'å…­æœ¬æœ¨ä¸€ä¸ç›®', 'å¸‚ãƒ¶è°·', 'å¤§é–€', 'æµœæ¾ç”º', 'ãƒ¢ãƒãƒ¬ãƒ¼ãƒ«æµœæ¾ç”º', 'ä¸­é‡', 'å››ãƒ„è°·', 'ä¸‰ç”°', 'ç”°ç”º', 'æ–°å®¿ä¸‰ä¸ç›®', 'ç¥ä¿ç”º', 'è¥¿æ–°å®¿', 'èµ¤å‚', 'èŒ…å ´ç”º', 'é«˜ç”°é¦¬å ´', 'å¾¡èŒ¶ãƒæ°´', 'æµ…è‰', 'ä¹æ®µä¸‹', 'é£¯ç”°æ©‹', 'å¾Œæ¥½åœ’', 'åŠè”µé–€', 'ç™½é‡‘å°', 'ç¯‰åœ°', 'ç™½é‡‘é«˜è¼ª', 'æ³‰å²³å¯º', 'å…«ä¸å €', 'åºƒå°¾', 'è‡ªç”±ãŒä¸˜', 'æ°´é“æ©‹', 'éº»å¸ƒåç•ª', 'ä»£å®˜å±±', 'ä¸‹åŒ—æ²¢', 'ä¸‰é·¹', 'éŒ¦ç³¸ç”º', 'ç«¹èŠ', 'æ–°å¤§ä¹…ä¿', 'è»çªª', 'å‹ã©ã', 'å—æ–°å®¿', 'ç«‹å·', 'æ­¦è”µå°æ‰', 'æ­¦è”µå°å±±', 'æ¡œæœ¨ç”º', 'å…ƒç”ºãƒ»ä¸­è¯è¡—', 'å¤§å®®', 'å›½ç«‹ç«¶æŠ€å ´', 'å›½ä¼šè­°äº‹å ‚å‰', 'å°å·ç”º', 'æ·¡è·¯ç”º', 'æ–°å¾¡èŒ¶ãƒæ°´', 'æ±æ—¥æœ¬æ©‹', 'é¦¬å–°æ¨ªå±±', 'é¦¬å–°ç”º', 'å²©æœ¬ç”º', 'æ—¥æ¯”è°·', 'ä¸Šé‡åºƒå°è·¯', 'ä»²å¾¡å¾’ç”º', 'æ˜¥æ—¥', 'ç‰›è¾¼ç¥æ¥½å‚', 'ä¹ƒæœ¨å‚', 'èµ¤ç¾½æ©‹', 'èŠå…¬åœ’', 'å¾¡æˆé–€', 'æ°¸ç”°ç”º', 'éº¹ç”º', 'å››è°·ä¸‰ä¸ç›®', 'åƒé§„ãƒ¶è°·', 'ä¿¡æ¿ƒç”º', 'ä»£ã€…æœ¨', 'åŸå®¿', 'æ˜æ²»ç¥å®®å‰', 'è¡¨å‚é“', 'å¤–è‹‘å‰', 'é’å±±ä¸€ä¸ç›®', 'èµ¤å‚è¦‹é™„', 'æºœæ± å±±ç‹', 'è™ãƒé–€', 'æ–°æ©‹', 'éŠ€åº§'],
    'P2': ['ç«¹æ©‹', 'ä¸Šé‡å¾¡å¾’ç”º', 'å¾¡å¾’ç”º', 'æ¡œç”°é–€', 'åŒ—åƒä½', 'æœ«åºƒç”º', 'å°å·ç”º', 'æ·¡è·¯ç”º', 'æ°¸ç”°ç”º', 'éº¹ç”º', 'å››è°·ä¸‰ä¸ç›®', 'å†…å¹¸ç”º', 'éƒ½åºå‰', 'å¤–è‹‘å‰', 'èµ¤å‚è¦‹é™„', 'æ–°æ©‹', 'å…­æœ¬æœ¨ä¸€ä¸ç›®', 'é’å±±ä¸€ä¸ç›®', 'éº»å¸ƒåç•ª', 'ç¥è°·ç”º', 'å¤§é–€', 'ç¥ä¿ç”º', 'ä¹æ®µä¸‹', 'åŠè”µé–€', 'å¸‚ãƒ¶è°·', 'é£¯ç”°æ©‹', 'å¾Œæ¥½åœ’', 'æ˜¥æ—¥', 'æœ¬éƒ·ä¸‰ä¸ç›®', 'æ¹¯å³¶', 'æ ¹æ´¥', 'åƒé§„æœ¨', 'è¥¿æ—¥æš®é‡Œ', 'ç”ºå±‹', 'æ–°å¾¡èŒ¶ãƒæ°´', 'å¤§æ‰‹ç”º', 'äºŒé‡æ©‹å‰', 'æ—¥æ¯”è°·', 'éœãƒ¶é–¢', 'å›½ä¼šè­°äº‹å ‚å‰', 'èµ¤å‚', 'ä¹ƒæœ¨å‚', 'æ˜æ²»ç¥å®®å‰', 'ä»£ã€…æœ¨å…¬åœ’', 'äº¬æˆä¸Šé‡', 'ä¸¡å›½', 'äº€æˆ¸', 'æ–°å°å²©', 'å°å²©', 'å¹³äº•', 'å¸‚å·', 'æœ¬å…«å¹¡', 'ä¸‹ç·ä¸­å±±', 'è¥¿èˆ¹æ©‹', 'èˆ¹æ©‹', 'æ±èˆ¹æ©‹', 'æ´¥ç”°æ²¼', 'å¹•å¼µæœ¬éƒ·', 'å¹•å¼µ', 'æ–°æ¤œè¦‹å·', 'ç¨²æ¯›', 'è¥¿åƒè‘‰', 'åƒè‘‰', 'æµ…è‰æ©‹', 'è”µå‰', 'æµ…è‰', 'å—åƒä½', 'åŒ—åƒä½', 'å—æŸ', 'æŸ', 'åŒ—æŸ', 'æˆ‘å­«å­', 'å¤©ç‹å°', 'å–æ‰‹', 'è—¤ä»£', 'ä½è²«', 'ç‰›ä¹…', 'ã²ãŸã¡é‡ã†ã—ã', 'è’å·æ²–', 'åœŸæµ¦', 'ç¥ç«‹', 'é«˜æµœ', 'çŸ³å²¡', 'ç¾½é³¥', 'å²©é–“', 'å‹éƒ¨', 'å†…åŸ', 'èµ¤å¡š', 'å•æ¥½åœ’', 'æ°´æˆ¸', 'å‹ç”°', 'ä½å’Œ', 'æ±æµ·', 'å¤§ç”•', 'å¸¸é™¸å¤šè³€', 'æ—¥ç«‹', 'å°æœ¨æ´¥', 'åç‹', 'é«˜è©', 'å—ä¸­éƒ·', 'ç£¯åŸ', 'å¤§æ´¥æ¸¯'],
    'P3': ['ä¸Šé‡åºƒå°è·¯', 'ä¿¡æ¿ƒç”º', 'æ—¥æš®é‡Œ', 'ç¯‰åœ°å¸‚å ´', 'å¤§å¡š', 'å¤§å¡šé§…å‰', 'ç¨²è·ç”º', 'ãŠå°å ´æµ·æµœå…¬åœ’', 'è±Šå³¶åœ’', 'å¤§å±±', 'æ–°ä¸­é‡', 'è¥¿æ–°å®¿äº”ä¸ç›®', 'æœˆå³¶', 'è±Šæ´²', 'è¾°å·³', 'æ–°æœ¨å ´', 'æ±é›²', 'å›½éš›å±•ç¤ºå ´', 'æ±äº¬ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ', 'å¤©ç‹æ´²ã‚¢ã‚¤ãƒ«', 'å“å·ã‚·ãƒ¼ã‚µã‚¤ãƒ‰', 'å¤§äº•ç«¶é¦¬å ´å‰', 'æµé€šã‚»ãƒ³ã‚¿ãƒ¼', 'æ˜­å’Œå³¶', 'æ•´å‚™å ´', 'å¤©ç©ºæ©‹', 'ç¾½ç”°ç©ºæ¸¯å›½éš›ç·šãƒ“ãƒ«', 'æ–°æ•´å‚™å ´', 'ç¾½ç”°ç©ºæ¸¯ç¬¬1ãƒ“ãƒ«', 'ç¾½ç”°ç©ºæ¸¯ç¬¬2ãƒ“ãƒ«', 'äº¬æ€¥è’²ç”°', 'ç³€è°·', 'å¤§é³¥å±…', 'ç©´å®ˆç¨²è·', 'å¤©ç©ºæ©‹', 'ç¾½ç”°ç©ºæ¸¯å›½éš›ç·šã‚¿ãƒ¼ãƒŸãƒŠãƒ«', 'ç¾½ç”°ç©ºæ¸¯å›½å†…ç·šã‚¿ãƒ¼ãƒŸãƒŠãƒ«', 'åƒä½å¤§æ©‹', 'äº¬æˆé–¢å±‹', 'å €åˆ‡è–è’²åœ’', 'ãŠèŠ±èŒ¶å±‹', 'é’ç ¥', 'äº¬æˆé«˜ç ‚', 'äº¬æˆå°å²©', 'æ±Ÿæˆ¸å·', 'å›½åºœå°', 'å¸‚å·çœŸé–“', 'è…é‡', 'äº¬æˆå…«å¹¡', 'é¬¼è¶Š', 'äº¬æˆä¸­å±±', 'æ±ä¸­å±±', 'äº¬æˆè¥¿èˆ¹', 'æµ·ç¥', 'äº¬æˆèˆ¹æ©‹', 'å¤§ç¥å®®ä¸‹', 'èˆ¹æ©‹ç«¶é¦¬å ´', 'è°·æ´¥', 'äº¬æˆæ´¥ç”°æ²¼', 'äº¬æˆå¤§ä¹…ä¿', 'å®Ÿç±¾', 'å…«åƒä»£å°', 'äº¬æˆå¤§å’Œç”°', 'å‹ç”°å°', 'å¿—æ´¥', 'ãƒ¦ãƒ¼ã‚«ãƒªãŒä¸˜', 'äº¬æˆè‡¼äº•', 'äº¬æˆä½å€‰', 'å¤§ä½å€‰', 'äº¬æˆé…’ã€…äº•', 'å®—å¾å‚é“', 'å…¬æ´¥ã®æœ', 'äº¬æˆæˆç”°', 'ç©ºæ¸¯ç¬¬2ãƒ“ãƒ«', 'æˆç”°ç©ºæ¸¯', 'æ±æˆç”°', 'èŠå±±åƒä»£ç”°', 'æˆç”°æ¹¯å·', 'å°æ—›æ—¥æœ¬åŒ»å¤§', 'å°è¥¿ç‰§ã®åŸ', 'åƒè‘‰ãƒ‹ãƒ¥ãƒ¼ã‚¿ã‚¦ãƒ³ä¸­å¤®', 'å°å®¤', 'ç™½äº•', 'è¥¿ç™½äº•', 'æ–°éŒãƒ¶è°·', 'å¤§ç”º', 'ãã¬ãå±±', 'å…ƒå±±', 'äº”é¦™', 'å¸¸ç›¤å¹³', 'å…«æŸ±', 'ã¿ã®ã‚Šå°', 'æ¾æˆ¸æ–°ç”°', 'ä¸Šæœ¬éƒ·', 'æ¾æˆ¸'],
    'P4': ['å¤§å´åºƒå°è·¯', 'ç”°åŸç”º', 'åƒçŸ³', 'æ¿æ©‹', 'ç¥æ³‰', 'å‚å®®æ©‹', 'ãƒ†ãƒ¬ã‚³ãƒ ã‚»ãƒ³ã‚¿ãƒ¼', 'åƒé§„æœ¨', 'æ–°é¦¬å ´', 'åŒ—å“å·', 'ä¸­å»¶', 'ä¸å‹•å‰', 'äººå½¢ç”º', 'æ±é•·å´', 'å¤©ç‹æ´²ã‚¢ã‚¤ãƒ«', 'ä¸‹æ¿æ©‹', 'é¦¬è¾¼', 'æ–°å¯Œç”º', 'ä¸­é‡å¯Œå£«è¦‹ç”º', 'å°å ´', 'ã¨ã†ãã‚‡ã†ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼', 'æ­¦è”µå¢ƒ', 'é§’è¾¼', 'ä»£ã€…æœ¨å…¬åœ’', 'éƒ½ç«‹å¤§å­¦', 'åƒæ­³çƒå±±', 'ä¸Šé‡æ¯›', 'é«˜è¼ªå°', 'æœ¬éƒ·ä¸‰ä¸ç›®', 'æœ¬æ‰€å¾å¦»æ©‹', 'å…¥è°·', 'æ±æ± è¢‹', 'æ£®ä¸‹', 'å°ä¼é¦¬ç”º', 'æ¸…æ¾„ç™½æ²³', 'æ°´å¤©å®®å‰', 'é–€å‰ä»²ç”º', 'æœ¨å ´', 'æ±é™½ç”º', 'å—ç ‚ç”º', 'è¥¿è‘›è¥¿', 'è‘›è¥¿', 'æµ¦å®‰', 'å—è¡Œå¾³', 'è¡Œå¾³', 'å¦™å…¸', 'åŸæœ¨ä¸­å±±', 'è¥¿èˆ¹æ©‹', 'æ±æµ·ç¥', 'é£¯å±±æº€', 'åŒ—ç¿’å¿—é‡', 'èˆ¹æ©‹æ—¥å¤§å‰', 'å…«åƒä»£ç·‘ãŒä¸˜', 'å…«åƒä»£ä¸­å¤®', 'æ‘ä¸Š', 'æ±è‘‰å‹ç”°å°', 'æ–°æŸ', 'å¢—å°¾', 'é€†äº•', 'é«˜æŸ³', 'å…­å®Ÿ', 'æ–°éŒãƒ¶è°·', 'éŒãƒ¶è°·', 'é¦¬è¾¼æ²¢', 'å¡šç”°', 'æ–°èˆ¹æ©‹', 'èˆ¹æ©‹', 'åƒè‘‰', 'æœ¬åƒè‘‰', 'è˜‡æˆ‘', 'æµœé‡', 'å…«å¹¡å®¿', 'äº”äº•', 'å§‰ã‚±å´', 'é•·æµ¦', 'è¢–ã‚±æµ¦', 'å·Œæ ¹', 'æœ¨æ›´æ´¥', 'å›æ´¥', 'é’å €', 'å¤§è²«', 'ä½è²«ç”º', 'ä¸Šç·æ¹Š', 'ç«¹å²¡', 'æµœé‡‘è°·', 'ä¿ç”°', 'å®‰æˆ¿å‹å±±', 'å²©äº•', 'å¯Œæµ¦', 'é‚£å¤èˆ¹å½¢', 'é¤¨å±±', 'ä¹é‡', 'åƒå€‰', 'åƒæ­³', 'å—ä¸‰åŸ', 'å’Œç”°æµ¦', 'æ±Ÿè¦‹', 'å¤ªæµ·', 'å®‰æˆ¿é´¨å·', 'å®‰æˆ¿å¤©æ´¥', 'å®‰æˆ¿å°æ¹Š', 'è¡Œå·ã‚¢ã‚¤ãƒ©ãƒ³ãƒ‰', 'ä¸Šç·èˆˆæ´¥', 'å®ˆè°·', 'ã¿ã‚‰ã„å¹³', 'ã¿ã©ã‚Šã®', 'ä¸‡åšè¨˜å¿µå…¬åœ’', 'ç ”ç©¶å­¦åœ’', 'ã¤ãã°'],
    'P5': ['æ–°æ¡œå°', 'æ±äº¬å›½éš›ã‚¯ãƒ«ãƒ¼ã‚ºã‚¿ãƒ¼ãƒŸãƒŠãƒ«', 'å¹³äº•', 'ä¸‰æ²³å³¶', 'æµœç”º', 'ä¸‰ãƒè¼ªæ©‹', 'ä¸‹è½åˆ', 'å°¾å±±å°', 'æ¡œå°', 'è¥¿å·£é´¨', 'é¦¬å–°æ¨ªå±±', 'å¤§å³¶', 'æ–°å®¿å¾¡è‹‘å‰', 'æ²¼è¢‹', 'è’²ç”°', 'æ±åŒ—æ²¢', 'å¤§äº•ç”º', 'åƒå·', 'é˜ãƒ¶æ·µ', 'åºƒå°¾', 'ä¸Šç”º', 'å…«åºƒ', 'æ°´é“æ©‹', 'å–œå¤šè¦‹', 'éº»å¸ƒåç•ª', 'å¤§é³¥å±…', 'ä»£å®˜å±±', 'èŠå·', 'ä¸‹åŒ—æ²¢', 'ä¹…ãŒåŸ', 'ä¸‰é·¹', 'æ± ãƒä¸Š', 'éŒ¦ç³¸ç”º', 'é«˜äº•æˆ¸', 'ç«¹èŠ', 'å¤§æ£®ç”º', 'æ–°å¤§ä¹…ä¿', 'è‹¥æ—', 'è»çªª', 'è¥¿æ°¸ç¦', 'å‹ã©ã', 'é•·åŸ', 'å—æ–°å®¿', 'ä¹…æˆ‘å±±', 'è¥¿å¤ªå­å ‚', 'æµ…è‰æ©‹', 'æ±Ÿå¤ç”°', 'ä½å‰', 'å—é˜¿ä½ãƒ¶è°·', 'ç¥å¤©å¯º', 'ç‹å­', 'èˆ¹ã®ç§‘å­¦é¤¨', 'ä¸­é‡å‚ä¸Š', 'èŒ—è·è°·', 'è½åˆå—é•·å´', 'æ–°æ±Ÿå¤ç”°', 'ç·´é¦¬æ˜¥æ—¥ç”º', 'å…‰ãŒä¸˜', 'åœ°ä¸‹é‰„æˆå¢—', 'åœ°ä¸‹é‰„èµ¤å¡š', 'å¹³å’Œå°', 'æ°·å·å°', 'å°ç«¹å‘åŸ', 'åƒå·', 'è¦ç”º', 'æ± è¢‹', 'æ±æ± è¢‹', 'è­·å›½å¯º', 'æ±Ÿæˆ¸å·æ©‹', 'é£¯ç”°æ©‹', 'å¸‚ãƒ¶è°·', 'éº¹ç”º', 'æ°¸ç”°ç”º', 'æ¡œç”°é–€', 'æœ‰æ¥½ç”º', 'éŠ€åº§ä¸€ä¸ç›®', 'æ–°å¯Œç”º', 'æœˆå³¶', 'è±Šæ´²', 'è¾°å·³', 'æ–°æœ¨å ´'],
    'P6': ['èŠæµ¦ãµé ­', 'å›½éš›å±•ç¤ºå ´', 'è’å·åŒºå½¹æ‰€å‰', 'å­¦ç¿’é™¢ä¸‹', 'æ–°ä¸‰æ²³å³¶', 'å·£é´¨æ–°ç”°', 'å¿—æ‘å‚ä¸Š', 'æœ‰æ˜ãƒ†ãƒ‹ã‚¹ã®æ£®', 'å €åˆ‡', 'æ˜­å’Œå³¶', 'è¥¿å¤§äº•', 'æ´—è¶³', 'æ±ã‚ãšã¾', 'é˜¿ä½ãƒ¶è°·', 'è¥¿å¤§å³¶', 'äº€æˆ¸æ°´ç¥', 'ä¸å‹•å‰', 'ç­‰ã€…åŠ›', 'æ²¼éƒ¨', 'äººå½¢ç”º', 'æ±é•·å´', 'é«˜å³¶ç”º', 'æ–°é«˜å††å¯º', 'å¹³æ²¼æ©‹', 'ç¬¹ï¨', 'ä¸‹æ¿æ©‹', 'è’å·äºŒä¸ç›®', 'ç›®ç™½', 'é¦¬è¾¼', 'ç¾½ç”°ç©ºæ¸¯å›½å†…ç·šã‚¿ãƒ¼ãƒŸãƒŠãƒ«', 'æ–°å¯Œç”º', 'æ±æ¾åŸ', 'è½åˆ', 'äº¬ç‹å¤šæ‘©ã‚»ãƒ³ã‚¿ãƒ¼', 'å°å ´', 'åƒä½å¤§æ©‹', 'ã¨ã†ãã‚‡ã†ã‚¹ã‚«ã‚¤ãƒ„ãƒªãƒ¼', 'ä¸‹ä¸¸å­', 'æ­¦è”µå¢ƒ', 'æ±å¤§å³¶', 'é§’è¾¼', 'é›‘è‰²', 'ä»£ã€…æœ¨å…¬åœ’', 'å¾¡å¶½å±±', 'éƒ½ç«‹å¤§å­¦', 'åƒé³¥ç”º', 'åƒæ­³çƒå±±', 'ä¸–ç”°è°·ä»£ç”°'],
    'P7': ['æ—¥ã®å‡º', 'é¢å½±æ©‹', 'æœ‰æ˜', 'é£›é³¥å±±', 'éƒ½é›»é›‘å¸ãƒ¶è°·', 'æ»é‡å·ä¸€ä¸ç›®', 'æµ®é–“èˆŸæ¸¡', 'å¿—æ‘ä¸‰ä¸ç›®', 'æ–°é«˜å³¶å¹³', 'æ „ç”º', 'å°ç”°æ€¥æ°¸å±±', 'æ±Ÿæˆ¸å·', 'å¤šæ‘©å‹•ç‰©å…¬åœ’', 'ç¥å¥ˆå·', 'ç¾½ç”°ç©ºæ¸¯å›½éš›ç·šãƒ“ãƒ«', 'è±Šç”°', 'æ±æ‘å±±', 'ãŠèŠ±èŒ¶å±‹', 'ä¹…ç±³å·', 'æ­¦è”µé–¢', 'äº¬ç‹å €ä¹‹å†…', 'å—å¤§æ²¢', 'åŒ—åºœä¸­', 'çŸ¢å·', 'çŸ¢é‡å£', 'ç«¶è‰‡å ´å‰', 'å—å¹³', 'ç®±æ ¹ãƒ¶å´', 'ç™¾è‰åœ’', 'é«˜å¹¡ä¸å‹•', 'å¹³å±±åŸå€å…¬åœ’', 'é•·æ²¼', 'äº¬ç‹ç‰‡å€‰']
}

# Pãƒ©ãƒ³ã‚¯ã”ã¨ã®åŠ ç‚¹ã‚¹ã‚³ã‚¢å®šç¾©
RANK_POINTS = {
    'P0': 2.0, 'P1': 1.8, 'P2': 1.6, 'P3': 1.4,
    'P4': 1.2, 'P5': 1.0, 'P6': 0.8, 'P7': 0.5
}

# -------------------------------------------
# 1. ãƒšãƒ¼ã‚¸è¨­å®š
# -------------------------------------------
st.set_page_config(
    page_title="Scooter Port Visibility Scorer", 
    layout="wide",
    initial_sidebar_state="collapsed"
)

# -------------------------------------------
# 2. åº§æ¨™æŠ½å‡ºãƒ­ã‚¸ãƒƒã‚¯
# -------------------------------------------
def extract_coords_from_input(user_input):
    if not isinstance(user_input, str): return None
    user_input = user_input.strip()

    # ãƒ‘ã‚¿ãƒ¼ãƒ³A: ç›´æ¥åº§æ¨™å…¥åŠ›
    try:
        if ',' in user_input and 'http' not in user_input and not any(c in user_input for c in "éƒ½é“åºœçœŒå¸‚åŒºç”ºæ‘"):
            parts = user_input.split(',')
            return float(parts[0]), float(parts[1])
    except: pass

    # ãƒ‘ã‚¿ãƒ¼ãƒ³B: URLå…¥åŠ›
    if 'http' in user_input:
        try:
            response = requests.get(user_input, allow_redirects=True, timeout=5)
            final_url = response.url
            match = re.search(r'@(-?\d+\.\d+),(-?\d+\.\d+)', final_url)
            if match: return float(match.group(1)), float(match.group(2))
            parsed = urlparse(final_url)
            qs = parse_qs(parsed.query)
            if 'q' in qs:
                coords = qs['q'][0].split(',')
                if len(coords) >= 2: return float(coords[0]), float(coords[1])
            lat_match = re.search(r'!3d(-?\d+\.\d+)', final_url)
            lon_match = re.search(r'!4d(-?\d+\.\d+)', final_url)
            if lat_match and lon_match:
                return float(lat_match.group(1)), float(lon_match.group(1))
        except: return None

    # ãƒ‘ã‚¿ãƒ¼ãƒ³C: æ—¥æœ¬èªä½æ‰€å…¥åŠ›
    try:
        geolocator = Nominatim(user_agent="scooter_port_scorer_app")
        location = geolocator.geocode(user_input)
        if location: return location.latitude, location.longitude
    except: return None
    return None

# -------------------------------------------
# 3. åˆ†æãƒ­ã‚¸ãƒƒã‚¯ (AIåˆ¤å®šã‚¨ãƒ³ã‚¸ãƒ³)
# -------------------------------------------
@st.cache_data
def assess_visibility_rank_v2(lat, lon):
    ox.settings.log_console = False
    score = 0
    details = []

    # --- Check 1: é§…ã‚¢ã‚¯ã‚»ã‚¹ & ãƒ–ãƒ©ãƒ³ãƒ‰åˆ¤å®š ---
    tags_station = {'railway': ['station', 'subway_entrance'], 'public_transport': 'station'}
    try:
        # åŠå¾„240mä»¥å†…(å¾’æ­©3åˆ†)ã®é§…ã‚’æ¢ã™
        stations = ox.features.features_from_point((lat, lon), tags_station, dist=240)
        
        if not stations.empty:
            score += 3.0
            
            # æœ€å¯„ã‚Šã®é§…åã‚’ç‰¹å®š
            # OSMã®nameã‚¿ã‚°ã¯ "éŠ€åº§é§…" ã®ã‚ˆã†ã« "é§…" ãŒã¤ãã“ã¨ãŒå¤šã„
            # CSVãƒ‡ãƒ¼ã‚¿ã¯ "éŠ€åº§" ãªã®ã§ã€éƒ¨åˆ†ä¸€è‡´ã§æ¤œç´¢ã™ã‚‹
            
            # ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ¬ãƒ¼ãƒ ã« 'name' ã‚«ãƒ©ãƒ ãŒã‚ã‚‹ã‹ç¢ºèª
            nearest_station_name = "ä¸æ˜ãªé§…"
            if 'name' in stations.columns:
                # è¤‡æ•°ã®é§…ãŒã‚ã‚‹å ´åˆã€ä¸€ç•ªè¿‘ã„ã‚‚ã®ã‚’å–å¾—...ã—ãŸã„ãŒã€
                # ã“ã“ã§ã¯ã€Œæœ€ã‚‚ãƒ©ãƒ³ã‚¯ãŒé«˜ã„é§…ã€ã‚’å„ªå…ˆã—ã¦æ¡ç”¨ã™ã‚‹ãƒœãƒ¼ãƒŠã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã«ã™ã‚‹
                
                # é§…åãƒªã‚¹ãƒˆã‚’å–å¾— (æ¬ æå€¤é™¤å¤–)
                found_names = stations['name'].dropna().astype(str).tolist()
                
                best_rank = None
                best_rank_score = 0
                matched_name = ""

                # ç™ºè¦‹ã•ã‚ŒãŸå„é§…ã«ã¤ã„ã¦ã€P0~P7ãƒªã‚¹ãƒˆã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                for osm_name in found_names:
                    for p_rank, station_list in STATION_RANKS.items():
                        # ãƒªã‚¹ãƒˆå†…ã®åå‰ãŒã€OSMã®åå‰ã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹ (ä¾‹: "éŠ€åº§" in "éŠ€åº§é§…")
                        for db_name in station_list:
                            if db_name in osm_name:
                                # ãƒãƒƒãƒã—ãŸãƒ©ãƒ³ã‚¯ã®ã‚¹ã‚³ã‚¢
                                p_score = RANK_POINTS.get(p_rank, 0)
                                if p_score > best_rank_score:
                                    best_rank_score = p_score
                                    best_rank = p_rank
                                    matched_name = db_name # CSVä¸Šã®åå‰
                
                if best_rank:
                    score += best_rank_score
                    details.append(f"âœ… é§…å¾’æ­©3åˆ†: **{matched_name}** ({best_rank}) (+{3.0+best_rank_score}ç‚¹)")
                else:
                    # ãƒªã‚¹ãƒˆã«ãªã„é§…
                    if found_names:
                        details.append(f"âœ… é§…å¾’æ­©3åˆ†: {found_names[0]} (ãƒ©ãƒ³ã‚¯å¤–) (+3.0ç‚¹)")
                    else:
                        details.append(f"âœ… é§…å¾’æ­©3åˆ†åœå†… (+3.0ç‚¹)")
            else:
                 details.append(f"âœ… é§…å¾’æ­©3åˆ†åœå†… (+3.0ç‚¹)")
        else:
            details.append("ãƒ» é§…é  (0)")
    except Exception as e:
        details.append(f"é§…åˆ¤å®šã‚¨ãƒ©ãƒ¼: {e}")

    # --- Check 2: é“è·¯ã®ç¨®é¡ ---
    try:
        G_all = ox.graph_from_point((lat, lon), dist=100, network_type='all')
        u, v, key = ox.distance.nearest_edges(G_all, lon, lat)
        edge_data = G_all.get_edge_data(u, v)[key]
        highway = edge_data.get('highway', 'unknown')
        if isinstance(highway, list): highway = highway[0]

        major_roads = ['motorway', 'trunk', 'primary', 'secondary']
        medium_roads = ['tertiary']
        living_roads = ['residential', 'unclassified', 'living_street']
        non_vehicle = ['pedestrian', 'footway', 'path', 'steps', 'cycleway']

        final_highway = highway
        is_sidewalk_of_major = False

        if highway in non_vehicle:
            try:
                G_drive = ox.graph_from_point((lat, lon), dist=50, network_type='drive')
                u_d, v_d, key_d = ox.distance.nearest_edges(G_drive, lon, lat)
                edge_data_drive = G_drive.get_edge_data(u_d, v_d)[key_d]
                highway_drive = edge_data_drive.get('highway', 'unknown')
                if isinstance(highway_drive, list): highway_drive = highway_drive[0]
                if highway_drive in major_roads or highway_drive in medium_roads:
                    final_highway = highway_drive
                    is_sidewalk_of_major = True
                    details.append(f"â„¹ï¸ æ­©é“ä¸Šã§ã™ãŒæ¨ªã«{final_highway}ã‚’æ¤œçŸ¥")
            except: pass

        if final_highway in major_roads:
            score += 2.0
            details.append(f"âœ… å¹¹ç·šé“è·¯æ²¿ã„({final_highway}) (+2.0)")
        elif final_highway in medium_roads:
            score += 1.0
            details.append(f"âœ… ãƒã‚¹é€šã‚Š({final_highway}) (+1.0)")
        elif final_highway in living_roads:
            score += 0.5
            details.append(f"ğŸ  ç”Ÿæ´»é“è·¯({final_highway}) (+0.5)")
        elif highway in ['service']:
            details.append(f"âš ï¸ æ•·åœ°å†…/ç§é“ (0)")
        elif highway in non_vehicle and not is_sidewalk_of_major:
            details.append(f"â›”ï¸ è»Šä¸¡ä¸å¯ã‚¨ãƒªã‚¢({highway})")
        else:
            details.append(f"ãƒ» ç´°è¡—è·¯ (0)")
    except:
        details.append(f"âš ï¸ é“è·¯ãƒ‡ãƒ¼ã‚¿ã‚¨ãƒ©ãƒ¼")

    # --- Check 3: äº¤å·®ç‚¹åˆ¤å®š ---
    try:
        G_simple = ox.graph_from_point((lat, lon), dist=50, network_type='drive', simplify=True)
        nearest_node = ox.distance.nearest_nodes(G_simple, lon, lat)
        degree = G_simple.degree[nearest_node]
        if degree >= 3:
            score += 1.0
            details.append(f"âœ… äº¤å·®ç‚¹/è§’åœ° (+1.0)")
    except: pass

    # ãƒ©ãƒ³ã‚¯åˆ¤å®š (æœ€å¤§8ç‚¹æº€ç‚¹ã«å¤‰æ›´)
    # S: 5.5~, A: 4.0~, B: 2.5~, C: 1.0~
    if score >= 5.5:
        rank = "S"
        color = "green"
    elif score >= 4.0:
        rank = "A"
        color = "blue"
    elif score >= 2.5:
        rank = "B"
        color = "orange"
    elif score >= 1.0:
        rank = "C"
        color = "orange"
    else:
        rank = "D"
        color = "red"

    detail_str = " / ".join(details)
    return rank, score, detail_str, color

# -------------------------------------------
# 4. ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: ä¸¦åˆ—å®Ÿè¡Œç”¨
# -------------------------------------------
def process_single_row(row_data):
    index, row, target_col = row_data
    raw_input = str(row[target_col])
    coords = extract_coords_from_input(raw_input)

    result = {
        "index": index, "AIãƒ©ãƒ³ã‚¯": "ã‚¨ãƒ©ãƒ¼", "AIã‚¹ã‚³ã‚¢": 0,
        "AIåˆ¤å®šç†ç”±": "åº§æ¨™å–å¾—å¤±æ•—", "ç·¯åº¦": None, "çµŒåº¦": None
    }
    if coords:
        lat, lon = coords
        try:
            rank, score, detail, _ = assess_visibility_rank_v2(lat, lon)
            result["AIãƒ©ãƒ³ã‚¯"] = rank
            result["AIã‚¹ã‚³ã‚¢"] = score
            result["AIåˆ¤å®šç†ç”±"] = detail
            result["ç·¯åº¦"] = lat
            result["çµŒåº¦"] = lon
        except: result["AIåˆ¤å®šç†ç”±"] = "åˆ†æã‚¨ãƒ©ãƒ¼"
    return result

# -------------------------------------------
# 5. UIéƒ¨åˆ†
# -------------------------------------------
st.title("ğŸ›´ ãƒãƒ¼ãƒˆè¦–èªæ€§ãƒ»éœ€è¦åˆ¤å®šAI")

tab1, tab2 = st.tabs(["ğŸ“ å˜ä¸€æ¤œç´¢", "ğŸ“‚ ä¸€æ‹¬åˆ¤å®š(CSV)"])

with tab1:
    st.markdown("Googleãƒãƒƒãƒ—ã®URLã€åº§æ¨™ã€ã¾ãŸã¯ä½æ‰€ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚")
    user_input = st.text_input("å ´æ‰€ã®æƒ…å ±ã‚’å…¥åŠ›", placeholder="URL / åº§æ¨™ / ä½æ‰€", key="single_input")

    if st.button("åˆ¤å®šé–‹å§‹", type="primary", key="single_btn"):
        if not user_input: st.error("å…¥åŠ›ã—ã¦ãã ã•ã„")
        else:
            coords = extract_coords_from_input(user_input)
            if coords:
                lat, lon = coords
                st.markdown("### ğŸ“ åˆ¤å®šå ´æ‰€")
                df_map = pd.DataFrame({'lat': [lat], 'lon': [lon]})
                st.map(df_map, zoom=15)
                with st.spinner('AIåˆ†æä¸­...'):
                    rank, score, detail_str, color = assess_visibility_rank_v2(lat, lon)
                st.divider()
                col1, col2 = st.columns(2)
                with col1: st.markdown(f"ç·åˆãƒ©ãƒ³ã‚¯: :{color}[**{rank}**]")
                with col2: st.metric("ã‚¹ã‚³ã‚¢ (Max 8.0)", f"{score}")
                st.info(f"ã€åˆ¤å®šç†ç”±ã€‘ {detail_str}")
            else: st.error("å ´æ‰€ã‚’ç‰¹å®šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")

with tab2:
    st.markdown("""
    **CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚** (æ¨å¥¨: URLã¾ãŸã¯åº§æ¨™åˆ—)
    â€» æœ€å¤§5ä¸¦åˆ—ã§é«˜é€Ÿå‡¦ç†ã—ã¾ã™ã€‚ç„¡æ–™æ ãªã®ã§ã€ä¸€æ—¦ã¯ä¸Šé™20ç®‡æ‰€ã§ãŠé¡˜ã„ã—ã¾ã™ã€‚ï¼“âˆ’ï¼”åˆ†ã§CSVå‡ºåŠ›ã§ãã‚‹ã¨æ€ã„ã¾ã™ã€‚
    """)
    uploaded_file = st.file_uploader("CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—", type="csv")
    if uploaded_file:
        df = pd.read_csv(uploaded_file)
        st.dataframe(df.head(3))
        target_col = st.selectbox("ğŸ“ åº§æ¨™ã¾ãŸã¯URLãŒå…¥ã£ã¦ã„ã‚‹åˆ—", df.columns)
        if st.button("ä¸€æ‹¬åˆ¤å®šã‚’å®Ÿè¡Œ (é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰)", type="primary"):
            st.info("åˆ†æã‚’é–‹å§‹ã—ã¾ã™...")
            results = {}
            total = len(df)
            progress_bar = st.progress(0)
            status_text = st.empty()
            with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
                tasks = [executor.submit(process_single_row, (i, row, target_col)) for i, row in df.iterrows()]
                for i, future in enumerate(concurrent.futures.as_completed(tasks)):
                    res = future.result()
                    results[res["index"]] = res
                    progress_bar.progress((i + 1) / total)
                    status_text.text(f"åˆ†æä¸­... {i+1} / {total} ä»¶å®Œäº†")
            
            results_list = [results[i] for i in range(total)]
            df["AIãƒ©ãƒ³ã‚¯"] = [r["AIãƒ©ãƒ³ã‚¯"] for r in results_list]
            df["AIã‚¹ã‚³ã‚¢"] = [r["AIã‚¹ã‚³ã‚¢"] for r in results_list]
            df["AIåˆ¤å®šç†ç”±"] = [r["AIåˆ¤å®šç†ç”±"] for r in results_list]
            df["ç·¯åº¦"] = [r["ç·¯åº¦"] for r in results_list]
            df["çµŒåº¦"] = [r["çµŒåº¦"] for r in results_list]
            
            st.success(f"âœ… åˆ†æå®Œäº†ï¼")
            st.dataframe(df)
            csv = df.to_csv(index=False).encode('utf-8-sig')
            st.download_button("çµæœCSVã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰", data=csv, file_name="scooter_ai_results_fast.csv", mime="text/csv")
